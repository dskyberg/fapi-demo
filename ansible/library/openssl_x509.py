#!/usr/bin/python
# -*- coding: utf-8 -*-
#
# (c) 2017, Yanis Guenane <yanis+ansible@guenane.org>
#
# Ansible is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# Ansible is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with Ansible.  If not, see <http://www.gnu.org/licenses/>.

ANSIBLE_METADATA = {'metadata_version': '1.0',
                    'status': ['preview'],
                    'supported_by': 'community'}


DOCUMENTATION = '''
---
module: openssl_csr
author: "Yanis Guenane (@Spredzy)"
version_added: "2.4"
short_description: Generate OpenSSL Certificate Signing Request (CSR)
description:
    - "This module allows one to (re)generates OpenSSL certificate signing requests.
       It uses the pyOpenSSL python library to interact with openssl. This module support
       the subjectAltName extension. Note: At least one of commonName or subjectAltName must
       be specified."
requirements:
    - "python-pyOpenSSL"
options:
    state:
        required: false
        default: "present"
        choices: [ present, absent ]
        description:
            - Whether the certificate signing request should exist or not, taking action if the state is different from what is stated.
    digest:
        required: false
        default: "sha256"
        description:
            - Digest used when signing the certificate signing request with the private key
    privatekey_path:
        required: true
        description:
            - Path to the privatekey to use when signing the certificate signing request
    version:
        required: false
        default: 3
        description:
            - Version of the certificate signing request
    force:
        required: false
        default: False
        choices: [ True, False ]
        description:
            - Should the certificate signing request be forced regenerated by this ansible module
    path:
        required: true
        description:
            - Name of the folder in which the generated OpenSSL certificate signing request will be written
    subjectAltName:
        required: false
        description:
            - SAN extension to attach to the certificate signing request
    countryName:
        required: false
        aliases: [ 'C' ]
        description:
            - countryName field of the certificate signing request subject
    stateOrProvinceName:
        required: false
        aliases: [ 'ST' ]
        description:
            - stateOrProvinceName field of the certificate signing request subject
    localityName:
        required: false
        aliases: [ 'L' ]
        description:
            - localityName field of the certificate signing request subject
    organizationName:
        required: false
        aliases: [ 'O' ]
        description:
            - organizationName field of the certificate signing request subject
    organizationUnitName:
        required: false
        aliases: [ 'OU' ]
        description:
            - organizationUnitName field of the certificate signing request subject
    commonName:
        required: false
        aliases: [ 'CN' ]
        description:
            - commonName field of the certificate signing request subject
    emailAddress:
        required: false
        aliases: [ 'E' ]
        description:
            - emailAddress field of the certificate signing request subject
'''


EXAMPLES = '''
# Generate an OpenSSL Certificate Signing Request
- openssl_csr:
    path: /etc/ssl/csr/www.ansible.com.csr
    privatekey_path: /etc/ssl/private/ansible.com.pem
    commonName: www.ansible.com

# Generate an OpenSSL Certificate Signing Request with Subject information
- openssl_csr:
    path: /etc/ssl/csr/www.ansible.com.csr
    privatekey_path: /etc/ssl/private/ansible.com.pem
    countryName: FR
    organizationName: Ansible
    emailAddress: jdoe@ansible.com
    commonName: www.ansible.com

# Generate an OpenSSL Certificate Signing Request with subjectAltName extension
- openssl_csr:
    path: /etc/ssl/csr/www.ansible.com.csr
    privatekey_path: /etc/ssl/private/ansible.com.pem
    subjectAltName: 'DNS:www.ansible.com,DNS:m.ansible.com'

# Force re-generate an OpenSSL Certificate Signing Request
- openssl_csr:
    path: /etc/ssl/csr/www.ansible.com.csr
    privatekey_path: /etc/ssl/private/ansible.com.pem
    force: True
    commonName: www.ansible.com
'''


RETURN = '''
csr:
    description: Path to the generated Certificate Signing Request
    returned: changed or success
    type: string
    sample: /etc/ssl/csr/www.ansible.com.csr
subject:
    description: A dictionnary of the subject attached to the CSR
    returned: changed or success
    type: list
    sample: {'CN': 'www.ansible.com', 'O': 'Ansible'}
subjectAltName:
    description: The alternative names this CSR is valid for
    returned: changed or success
    type: string
    sample: 'DNS:www.ansible.com,DNS:m.ansible.com'
'''
import errno
import os
import sys
import random
from datetime import datetime, timedelta
from ansible.module_utils.basic import AnsibleModule
from ansible.module_utils._text import to_native

try:
    from OpenSSL import crypto
except ImportError:
    pyopenssl_found = False
else:
    pyopenssl_found = True


def x509_name(**attrs):
    """
    Return a new X509Name with the given attributes.
    """
    # XXX There's no other way to get a new X509Name yet.
    name = crypto.X509().get_subject()
    attrs = list(attrs.items())

    # Make the order stable - order matters!
    def key(attr):
        return attr[1]
    attrs.sort(key=key)
    for k, v in attrs:
        setattr(name, k, v)
    return name


def list_to_dict(lst):
    result = {}
    for item in lst:
        result[item[0]] = item[1]
    return result

def compare_keys(d1, d2):
    keys1 = d1.keys()
    keys2 = d2.keys()
    if len(keys1) != len(keys2):
        return False
    for key in keys1:
        if key not in keys2:
            return False
    return True


def compare_dict(d1, d2):
    if not compare_keys(d1, d2):
        return False
    for k, v in d1.items():
        if d2[k] != v:
            return False
    return True


class CertificateError(Exception):
    def __init__(self, message):
        self.message = message


class Certificate(object):

    def __init__(self, module):
        self.state = module.params['state']
        self.digest = module.params['digest']
        self.force = module.params['force']
        self.selfSigned = module.params['self_signed']
        self.path = module.params['path']
        self.chain_path = module.params['chain_path']
        self.csr_path = module.params['csr_path']
        self.privatekey_path = module.params['privatekey_path']
        self.issuer_cert_path = module.params['issuer_cert_path']
        self.issuer_privatekey_path = module.params['issuer_privatekey_path']
        self.version = module.params['version']
        self.serial = module.params['serial']
        self.days = module.params['days']
        self.v3_exts = module.params['extensions']
        self.changed = True
        self.x509 = None
        self.issuer = None
        self.csr = None
        self.privatekey = None
        self.subject = {}
        subject = {
            'C': module.params['countryName'],
            'ST': module.params['stateOrProvinceName'],
            'L': module.params['localityName'],
            'O': module.params['organizationName'],
            'OU': module.params['organizationalUnitName'],
            'CN': module.params['commonName'],
            'SN': module.params['surName'],
            'GN': module.params['givenName'],
            'emailAddress': module.params['emailAddress'],
        }
        for (key, value) in subject.items():
            if value is not None:
                self.subject[key] = value
        if len(self.subject) == 0:
            self.subject = None

    def loadFiles(self):
        '''Load the various files needed for signing, etc.'''

        if self.privatekey_path:
            privatekey_content = open(self.privatekey_path).read()
            self.privatekey = crypto.load_privatekey(crypto.FILETYPE_PEM, privatekey_content)

        if self.csr_path:
            csr_content = open(self.csr_path).read()
            self.csr = crypto.load_certificate_request(crypto.FILETYPE_PEM, csr_content)

        if self.issuer_privatekey_path:
            issuer_privatekey_content = open(self.issuer_privatekey_path).read()
            self.issuer_privatekey = crypto.load_privatekey(crypto.FILETYPE_PEM, issuer_privatekey_content)

        if self.issuer_cert_path:
            issuer_cert_content = open(self.issuer_cert_path).read()
            self.issuer = crypto.load_certificate(crypto.FILETYPE_PEM, issuer_cert_content)

    def set_serial_number(self, x509):
        '''If a serial number is not provided, a randum number is generated
            between the value 1000 and sys.maxint'''

        if not self.serial:
            random.seed()
            self.serial = random.randint(1000, sys.maxsize)
        x509.set_serial_number(self.serial)

    def set_validity(self, x509):
        '''Generate the properly formatted strings for notBefore and notAfter'''
        now = datetime.now()
        expire = datetime.now() + timedelta(days=self.days)
        x509.set_notBefore(now.strftime("%Y%m%d%H%M%SZ").encode())
        x509.set_notAfter(expire.strftime("%Y%m%d%H%M%SZ").encode())

    def set_subject(self, x509):
        '''If a CSR was provided, grab the subject from that.  Else, use the
        provided DN values'''

        if self.csr:
            x509.set_subject(self.csr.get_subject())
        else:
            subject = x509.get_subject()
            for (key, value) in self.subject.items():
                if value is not None:
                    setattr(subject, key, value)

    def set_pubkey(self, x509):
        '''If a CSR was provided, use the public key from that, else there
        must be a private key'''
        if self.csr is None and self.privatekey is None:
            raise CertificateError(message='There must be either a CSR or private key')

        if self.privatekey is not None:
            x509.set_pubkey(self.privatekey)
        else:
            x509.set_pubkey(self.csr.get_pubkey())

    def set_issuer(self, x509):
        if self.selfSigned:
            x509.set_issuer(x509.get_subject())
        else:
            x509.set_issuer(self.issuer.get_subject())

    def set_extensions(self, x509):
        if not self.v3_exts or len(self.v3_exts) == 0:
            return

        exts = []
        issuer = self.issuer or None
        for ext in self.v3_exts:
            name = ext['name'].encode()
            critical = hasattr(ext, 'critical') and ext['critical'] or False
            value = ext['value'].encode()
            exts.append(crypto.X509Extension(name, critical, value, subject=x509, issuer=issuer))
        x509.add_extensions(exts)

    def sign(self, x509):
        pkey = self.selfSigned and self.privatekey or self.issuer_privatekey
        x509.sign(pkey, self.digest)

    def compare(self, module):
        '''For self signed, if the cert already exists, compare it to see if any of the DN values
        have changed. Returns True if the values match, or there is no current file.'''

        if not self.selfSigned or not os.path.exists(self.path):
            return True

        cert_content = open(self.path).read()
        x509 = crypto.load_certificate(crypto.FILETYPE_PEM, cert_content)
        x509_subject = list_to_dict(x509.get_subject().get_components())
        subject = list_to_dict(x509_name(**self.subject).get_components())

        return compare_dict(x509_subject, subject)

    def generate(self, module):
        '''Generate the X509 certificate.'''

        if not os.path.exists(self.path) or self.force or not self.compare(module):
            # Loads the private keys, cert and csr (if provided)
            self.loadFiles()

            x509 = crypto.X509()
            x509.set_version(self.version-1)
            self.set_serial_number(x509)
            self.set_validity(x509)
            self.set_subject(x509)
            self.set_pubkey(x509)
            self.set_issuer(x509)
            self.set_extensions(x509)

            self.sign(x509)
            self.x509 = x509

            try:
                x509_file = open(self.path, 'wb')
                x509_file.write(crypto.dump_certificate(crypto.FILETYPE_PEM, self.x509))
                x509_file.close()
                if self.chain_path:
                    chain_file = open(self.chain_path, 'wb')
                    chain_file.write(crypto.dump_certificate(crypto.FILETYPE_PEM, self.x509))
                    chain_file.write(crypto.dump_certificate(crypto.FILETYPE_PEM, self.issuer))
                    chain_file.close()
            except (IOError, OSError) as exc:
                raise CertificateError(exc)
        else:
            self.changed = False

        file_args = module.load_file_common_arguments(module.params)
        if module.set_fs_attributes_if_different(file_args, False):
            self.changed = True

    def remove(self):
        '''Remove the Certificate Signing Request.'''

        try:
            os.remove(self.path)
        except OSError as exc:
            if exc.errno != errno.ENOENT:
                raise CertificateError(exc)
            else:
                self.changed = False

    def dump(self):
        '''Serialize the object into a dictionary.'''

        result = {
            'x509': self.path,
            'changed': self.changed
        }

        return result


def main():
    module = AnsibleModule(
        argument_spec=dict(
            state=dict(default='present', choices=['present', 'absent'], type='str'),
            force=dict(default=False, type='bool'),
            path=dict(required=True, type='path'),
            chain_path=dict(type='path'),
            self_signed=dict(type='bool', default=False),
            digest=dict(default='sha256', type='str'),
            csr_path=dict(type='str'),
            privatekey_path=dict(type='path'),
            issuer_cert_path=dict(type='path'),
            issuer_privatekey_path=dict(type='path'),
            version=dict(default='3', choices=[1, 2, 3], type='int'),
            serial=dict(type='int'),
            days=dict(type='int', default=365),
            extensions=dict(aliases=['v3_exts'], type='list'),
            countryName=dict(aliases=['C'], type='str'),
            stateOrProvinceName=dict(aliases=['ST'], type='str'),
            localityName=dict(aliases=['L'], type='str'),
            organizationName=dict(aliases=['O'], type='str'),
            organizationalUnitName=dict(aliases=['OU'], type='str'),
            commonName=dict(aliases=['CN'], type='str'),
            surName=dict(aliases=['SN'], type='str'),
            givenName=dict(aliases=['GN'], type='str'),
            emailAddress=dict(aliases=['E'], type='str'),
        ),
        add_file_common_args=True,
        supports_check_mode=True,
        required_one_of=[['privatekey_path', 'csr_path']],
    )

    path = module.params['path']
    base_dir = os.path.dirname(module.params['path'])

    if not os.path.isdir(base_dir):
        module.fail_json(name=path, msg='The directory %s does not exist' % path)

    x509 = Certificate(module)

    if module.params['state'] == 'present':

        if module.check_mode:
            result = x509.dump()
            result['changed'] = module.params['force'] or not os.path.exists(path)
            module.exit_json(**result)

        try:
            x509.generate(module)
        except CertificateError as exc:
            module.fail_json(msg=to_native(exc))

    else:

        if module.check_mode:
            result = x509.dump()
            result['changed'] = os.path.exists(path)
            module.exit_json(**result)

        try:
            x509.remove()
        except CertificateError as exc:
            module.fail_json(msg=to_native(exc))

    result = x509.dump()

    module.exit_json(**result)


if __name__ == "__main__":
    main()